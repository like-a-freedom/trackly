// POI Deduplication Service
// Handles finding or creating POIs with intelligent deduplication

use crate::models::ParsedWaypoint;
use sqlx::PgPool;
use tracing::{debug, info, warn};
use uuid::Uuid;

pub struct PoiDeduplicationService;

impl PoiDeduplicationService {
    /// Find or create POI using hash-based deduplication
    /// Uses INSERT ON CONFLICT for atomic operation - no race conditions
    /// Returns the POI id
    pub async fn find_or_create_poi(
        pool: &PgPool,
        waypoint: &ParsedWaypoint,
    ) -> Result<i32, sqlx::Error> {
        debug!(
            "Finding or creating POI: {} at ({}, {})",
            waypoint.name, waypoint.lat, waypoint.lon
        );

        // Use INSERT ON CONFLICT for atomic deduplication
        // The dedup_hash is automatically generated by PostgreSQL
        let result = sqlx::query_scalar::<_, i32>(
            r#"
            INSERT INTO pois (name, description, category, elevation, geom)
            VALUES (
                $1, $2, $3, $4,
                ST_SetSRID(ST_MakePoint($5, $6), 4326)::geography
            )
            ON CONFLICT (dedup_hash) DO UPDATE
            SET 
                description = COALESCE(pois.description, EXCLUDED.description),
                category = COALESCE(pois.category, EXCLUDED.category),
                elevation = COALESCE(pois.elevation, EXCLUDED.elevation),
                updated_at = NOW()
            RETURNING id
            "#,
        )
        .bind(waypoint.name.trim())
        .bind(&waypoint.description)
        .bind(&waypoint.category)
        .bind(waypoint.elevation)
        .bind(waypoint.lon)
        .bind(waypoint.lat)
        .fetch_one(pool)
        .await?;

        info!("POI id {} for '{}'", result, waypoint.name);
        Ok(result)
    }

    /// Link POI to track with distance calculation
    pub async fn link_poi_to_track(
        pool: &PgPool,
        track_id: Uuid,
        poi_id: i32,
        sequence_order: i32,
    ) -> Result<(), sqlx::Error> {
        debug!(
            "Linking POI {} to track {} with sequence {}",
            poi_id, track_id, sequence_order
        );

        // Calculate distance from track start using PostGIS function
        let distance: Option<f32> = sqlx::query_scalar(
            r#"
            SELECT calculate_poi_distance_on_track($1, $2)
            "#,
        )
        .bind(track_id)
        .bind(poi_id)
        .fetch_one(pool)
        .await?;

        debug!(
            "Calculated distance: {} meters from track start",
            distance.unwrap_or(0.0)
        );

        // Insert or update link
        sqlx::query(
            r#"
            INSERT INTO track_pois (track_id, poi_id, distance_from_start_m, sequence_order)
            VALUES ($1, $2, $3, $4)
            ON CONFLICT (track_id, poi_id) DO UPDATE
            SET distance_from_start_m = EXCLUDED.distance_from_start_m,
                sequence_order = EXCLUDED.sequence_order
            "#,
        )
        .bind(track_id)
        .bind(poi_id)
        .bind(distance)
        .bind(sequence_order)
        .execute(pool)
        .await?;

        Ok(())
    }

    /// Batch link POIs to track
    /// Processes all waypoints and creates/links POIs in sequence
    pub async fn link_pois_to_track(
        pool: &PgPool,
        track_id: Uuid,
        waypoints: Vec<ParsedWaypoint>,
    ) -> Result<usize, sqlx::Error> {
        if waypoints.is_empty() {
            debug!("No waypoints to link for track {}", track_id);
            return Ok(0);
        }

        info!(
            "Linking {} waypoints to track {}",
            waypoints.len(),
            track_id
        );

        let mut count = 0;

        for (idx, waypoint) in waypoints.into_iter().enumerate() {
            match Self::find_or_create_poi(pool, &waypoint).await {
                Ok(poi_id) => {
                    if let Err(e) =
                        Self::link_poi_to_track(pool, track_id, poi_id, idx as i32).await
                    {
                        warn!("Failed to link POI {} to track {}: {}", poi_id, track_id, e);
                        // Continue with other POIs even if one fails
                        continue;
                    }
                    count += 1;
                }
                Err(e) => {
                    warn!("Failed to create POI '{}': {}", waypoint.name, e);
                    // Continue with other POIs even if one fails
                    continue;
                }
            }
        }

        info!(
            "Successfully linked {} out of {} POIs to track {}",
            count, count, track_id
        );

        Ok(count)
    }

    /// Find potential duplicates using fuzzy matching
    /// Used for suggesting merges to users
    #[allow(dead_code)]
    pub async fn find_potential_duplicates(
        pool: &PgPool,
        poi_id: i32,
        similarity_threshold: f32,
        distance_threshold_m: f32,
    ) -> Result<Vec<i32>, sqlx::Error> {
        debug!(
            "Finding potential duplicates for POI {} (similarity: {}, distance: {}m)",
            poi_id, similarity_threshold, distance_threshold_m
        );

        let results = sqlx::query_scalar::<_, i32>(
            r#"
            SELECT p2.id
            FROM pois p1
            JOIN pois p2 ON p2.id != p1.id
            WHERE p1.id = $1
              AND ST_DWithin(p1.geom, p2.geom, $2)
              AND similarity(p1.name, p2.name) > $3
            ORDER BY ST_Distance(p1.geom, p2.geom), similarity(p1.name, p2.name) DESC
            LIMIT 10
            "#,
        )
        .bind(poi_id)
        .bind(distance_threshold_m as f64)
        .bind(similarity_threshold)
        .fetch_all(pool)
        .await?;

        debug!("Found {} potential duplicates", results.len());

        Ok(results)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::ParsedWaypoint;

    #[test]
    fn test_poi_deduplication_service_exists() {
        // Ensure the service can be instantiated
        let _service = PoiDeduplicationService;
    }

    #[test]
    fn test_parsed_waypoint_creation() {
        let waypoint = ParsedWaypoint {
            name: "Test Summit".to_string(),
            description: Some("A beautiful mountain peak".to_string()),
            category: Some("Summit".to_string()),
            lat: 55.7558,
            lon: 37.6173,
            elevation: Some(2500.0),
        };

        assert_eq!(waypoint.name, "Test Summit");
        assert_eq!(waypoint.lat, 55.7558);
        assert_eq!(waypoint.lon, 37.6173);
        assert_eq!(waypoint.elevation, Some(2500.0));
    }

    #[test]
    fn test_parsed_waypoint_minimal() {
        // Test with minimal data (no description, category, or elevation)
        let waypoint = ParsedWaypoint {
            name: "Minimal POI".to_string(),
            description: None,
            category: None,
            lat: 50.0,
            lon: 10.0,
            elevation: None,
        };

        assert_eq!(waypoint.name, "Minimal POI");
        assert!(waypoint.description.is_none());
        assert!(waypoint.category.is_none());
        assert!(waypoint.elevation.is_none());
    }
}
